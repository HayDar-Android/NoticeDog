/*
 * Copyright (c) NoticeDog 2017.
 * GNU LESSER GENERAL PUBLIC LICENSE
 *     Version 3, 29 June 2007
 *
 * Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 * Everyone is permitted to copy and distribute verbatim copies
 * of this license document, but changing it is not allowed.
 *
 *
 * This version of the GNU Lesser General Public License incorporates
 * the terms and conditions of version 3 of the GNU General Public
 * License, supplemented by the additional permissions listed below.
 *
 * 0. Additional Definitions.
 *
 * As used herein, "this License" refers to version 3 of the GNU Lesser
 * General Public License, and the "GNU GPL" refers to version 3 of the GNU
 * General Public License.
 *
 * "The Library" refers to a covered work governed by this License,
 * other than an Application or a Combined Work as defined below.
 *
 * An "Application" is any work that makes use of an interface provided
 * by the Library, but which is not otherwise based on the Library.
 * Defining a subclass of a class defined by the Library is deemed a mode
 * of using an interface provided by the Library.
 *
 * A "Combined Work" is a work produced by combining or linking an
 * Application with the Library.  The particular version of the Library
 * with which the Combined Work was made is also called the "Linked
 * Version".
 *
 * The "Minimal Corresponding Source" for a Combined Work means the
 * Corresponding Source for the Combined Work, excluding any source code
 * for portions of the Combined Work that, considered in isolation, are
 * based on the Application, and not on the Linked Version.
 *
 * The "Corresponding Application Code" for a Combined Work means the
 * object code and/or source code for the Application, including any data
 * and utility programs needed for reproducing the Combined Work from the
 * Application, but excluding the System Libraries of the Combined Work.
 *
 * 1. Exception to Section 3 of the GNU GPL.
 *
 * You may convey a covered work under sections 3 and 4 of this License
 * without being bound by section 3 of the GNU GPL.
 *
 * 2. Conveying Modified Versions.
 *
 * If you modify a copy of the Library, and, in your modifications, a
 * facility refers to a function or data to be supplied by an Application
 * that uses the facility (other than as an argument passed when the
 * facility is invoked), then you may convey a copy of the modified
 * version:
 *
 * a) under this License, provided that you make a good faith effort to
 * ensure that, in the event an Application does not supply the
 * function or data, the facility still operates, and performs
 * whatever part of its purpose remains meaningful, or
 *
 * b) under the GNU GPL, with none of the additional permissions of
 * this License applicable to that copy.
 *
 * 3. Object Code Incorporating Material from Library Header Files.
 *
 * The object code form of an Application may incorporate material from
 * a header file that is part of the Library.  You may convey such object
 * code under terms of your choice, provided that, if the incorporated
 * material is not limited to numerical parameters, data structure
 * layouts and accessors, or small macros, inline functions and templates
 * (ten or fewer lines in length), you do both of the following:
 *
 * a) Give prominent notice with each copy of the object code that the
 * Library is used in it and that the Library and its use are
 * covered by this License.
 *
 * b) Accompany the object code with a copy of the GNU GPL and this license
 * document.
 *
 * 4. Combined Works.
 *
 * You may convey a Combined Work under terms of your choice that,
 * taken together, effectively do not restrict modification of the
 * portions of the Library contained in the Combined Work and reverse
 * engineering for debugging such modifications, if you also do each of
 * the following:
 *
 * a) Give prominent notice with each copy of the Combined Work that
 * the Library is used in it and that the Library and its use are
 * covered by this License.
 *
 * b) Accompany the Combined Work with a copy of the GNU GPL and this license
 * document.
 *
 * c) For a Combined Work that displays copyright notices during
 * execution, include the copyright notice for the Library among
 * these notices, as well as a reference directing the user to the
 * copies of the GNU GPL and this license document.
 *
 * d) Do one of the following:
 *
 * 0) Convey the Minimal Corresponding Source under the terms of this
 * License, and the Corresponding Application Code in a form
 * suitable for, and under terms that permit, the user to
 * recombine or relink the Application with a modified version of
 * the Linked Version to produce a modified Combined Work, in the
 * manner specified by section 6 of the GNU GPL for conveying
 * Corresponding Source.
 *
 * 1) Use a suitable shared library mechanism for linking with the
 * Library.  A suitable mechanism is one that (a) uses at run time
 * a copy of the Library already present on the user's computer
 * system, and (b) will operate properly with a modified version
 * of the Library that is interface-compatible with the Linked
 * Version.
 *
 * e) Provide Installation Information, but only if you would otherwise
 * be required to provide such information under section 6 of the
 * GNU GPL, and only to the extent that such information is
 * necessary to install and execute a modified version of the
 * Combined Work produced by recombining or relinking the
 * Application with a modified version of the Linked Version. (If
 * you use option 4d0, the Installation Information must accompany
 * the Minimal Corresponding Source and Corresponding Application
 * Code. If you use option 4d1, you must provide the Installation
 * Information in the manner specified by section 6 of the GNU GPL
 * for conveying Corresponding Source.)
 *
 * 5. Combined Libraries.
 *
 * You may place library facilities that are a work based on the
 * Library side by side in a single library together with other library
 * facilities that are not Applications and are not covered by this
 * License, and convey such a combined library under terms of your
 * choice, if you do both of the following:
 *
 * a) Accompany the combined library with a copy of the same work based
 * on the Library, uncombined with any other library facilities,
 * conveyed under the terms of this License.
 *
 * b) Give prominent notice with the combined library that part of it
 * is a work based on the Library, and explaining where to find the
 * accompanying uncombined form of the same work.
 *
 * 6. Revised Versions of the GNU Lesser General Public License.
 *
 * The Free Software Foundation may publish revised and/or new versions
 * of the GNU Lesser General Public License from time to time. Such new
 * versions will be similar in spirit to the present version, but may
 * differ in detail to address new problems or concerns.
 *
 * Each version is given a distinguishing version number. If the
 * Library as you received it specifies that a certain numbered version
 * of the GNU Lesser General Public License "or any later version"
 * applies to it, you have the option of following the terms and
 * conditions either of that published version or of any later version
 * published by the Free Software Foundation. If the Library as you
 * received it does not specify a version number of the GNU Lesser
 * General Public License, you may choose any version of the GNU Lesser
 * General Public License ever published by the Free Software Foundation.
 *
 * If the Library as you received it specifies that a proxy can decide
 * whether future versions of the GNU Lesser General Public License shall
 * apply, that proxy's public statement of acceptance of any version is
 * permanent authorization for you to choose that version for the
 * Library.
 */

package io.bunnyblue.noticedog.app.apps.mms;

import android.annotation.TargetApi;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.database.ContentObserver;
import android.database.Cursor;
import android.net.Uri;
import android.os.Handler;
import android.os.Looper;
import android.provider.Telephony.Mms.Inbox;
import android.provider.Telephony.MmsSms;
import android.telephony.TelephonyManager;
import android.util.Log;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import io.bunnyblue.noticedog.app.R;

public class MmsMonitor {
    private static final String ACTION_MMS_DOWNLOADED = "android.intent.action.TRANSACTION_COMPLETED_ACTION";
    private static final int ADDR_TYPE_FROM = 137;
    private static final int ADDR_TYPE_TO = 151;
    private static final String[] CONTENT_TYPE_AUDIO = new String[]{"audio/*", "audio/aac", "audio/amr", "audio/imelody", "audio/mid", "audio/midi", "audio/mp3", "audio/mpeg3", "audio/mpeg", "audio/mpg", "audio/mp4", "audio/x-mid", "audio/x-midi", "audio/x-mp3", "audio/x-mpeg3", "audio/x-mpeg", "audio/x-mpg", "audio/3gpp", "audio/x-wav", "application/ogg"};
    private static final String[] CONTENT_TYPE_CALENDARS = new String[]{"text/x-vCalendar"};
    private static final String[] CONTENT_TYPE_CONTACTS = new String[]{"text/x-vcard"};
    private static final String CONTENT_TYPE_HTML = "text/html";
    private static final String[] CONTENT_TYPE_IMAGES = new String[]{"image/*", "image/jpeg", "image/jpg", "image/gif", "image/vnd.wap.wbmp", "image/png", "image/x-ms-bmp"};
    private static final String CONTENT_TYPE_TEXT = "text/plain";
    private static final String[] CONTENT_TYPE_VIDEOS = new String[]{"video/*", "video/3gpp", "video/3gpp2", "video/h263", "video/mp4"};
    private static final long MAX_WAIT_TIME_FOR_MMS = 30000;
    private static final String MMS_SORT_ORDER = "_id desc";
    private static final String TAG = "MmsMonitor";
    Context context;
    long lastMessageId;
    List<MmsListener> listeners;
    MmsContentObserver mmsContentObserver;
    MmsDownloadedReceiver mmsDownloadedReceiver;
    List<PendingMms> pendingMessages;

    @TargetApi(19)
    public void start(Context context) {
        this.context = context;
        this.listeners = new ArrayList();
        this.pendingMessages = new ArrayList();
        this.mmsDownloadedReceiver = null;
        this.mmsContentObserver = null;
        this.mmsContentObserver = new MmsContentObserver(new Handler(Looper.getMainLooper()));
        context.getContentResolver().registerContentObserver(MmsSms.CONTENT_URI, true, this.mmsContentObserver);
        this.lastMessageId = -1;
        loadLastMessageId();
    }

    public void stop() {
        if (this.mmsContentObserver != null) {
            this.context.getContentResolver().unregisterContentObserver(this.mmsContentObserver);
            this.mmsContentObserver = null;
        }
        if (this.mmsDownloadedReceiver != null) {
            this.context.unregisterReceiver(this.mmsDownloadedReceiver);
            this.mmsDownloadedReceiver = null;
        }
        this.listeners = null;
        this.context = null;
    }

    public void addMMSListener(MmsListener listener) {
        this.listeners.add(listener);
    }

    public void removeMMSListener(MmsListener listener) {
        this.listeners.remove(listener);
    }

    @TargetApi(19)
    void loadLastMessageId() {
        Cursor cursor = this.context.getContentResolver().query(Inbox.CONTENT_URI, null, null, null, MMS_SORT_ORDER);
        if (cursor.moveToFirst()) {
            this.lastMessageId = cursor.getLong(cursor.getColumnIndex("_id"));
        }
        cursor.close();
    }

    @TargetApi(19)
    void onConversationDatabaseChanged() {
        Cursor cursor = this.context.getContentResolver().query(Inbox.CONTENT_URI, null, null, null, MMS_SORT_ORDER);
        long messageId = -1;
        if (cursor.moveToFirst()) {
            messageId = cursor.getLong(cursor.getColumnIndex("_id"));
        }
        cursor.close();
        if (messageId != -1 && messageId > this.lastMessageId) {
            Log.d(TAG, "Adding messageId = " + messageId + " to the pending list");
            long pendingId = messageId;
            if (!this.pendingMessages.contains(Long.valueOf(pendingId))) {
                addPendingMessage(pendingId);
            }
        }
        this.lastMessageId = messageId;
        flushPendingMessages();
    }

    void addPendingMessage(long messageId) {
        for (PendingMms pendingMessage : this.pendingMessages) {
            if (pendingMessage.messageId == messageId) {
                return;
            }
        }
        this.pendingMessages.add(new PendingMms(messageId, System.currentTimeMillis()));
    }

    void flushPendingMessages() {
        Iterator<PendingMms> iter = this.pendingMessages.iterator();
        List<MmsMessage> mmsMessages = new ArrayList();
        while (iter.hasNext()) {
            PendingMms pendingMms = (PendingMms) iter.next();
            MmsMessage mmsMessage = getMMS(pendingMms.messageId);
            if (mmsMessage != null) {
                iter.remove();
                mmsMessages.add(mmsMessage);
            } else if (System.currentTimeMillis() - pendingMms.timestamp > 30000) {
                iter.remove();
            }
        }
        for (MmsMessage mmsMessage2 : mmsMessages) {
            fireOnMmsReceived(mmsMessage2);
        }
    }

    void fireOnMmsReceived(MmsMessage mmsMessage) {
        for (MmsListener listener : this.listeners) {
            listener.onMmsReceived(mmsMessage);
        }
    }

    MmsMessage getMMS(long messageId) {
        String message = null;
        String senderAddress = null;
        List<String> recipientAddresses = new ArrayList();
        Uri uri = Uri.parse("content://mms/" + messageId + "/addr");
        Cursor cursor = this.context.getContentResolver().query(uri, null, new String("msg_id=" + messageId + " AND type=" + 137), null, null);
        Log.d(TAG, "Found " + cursor.getCount() + " sender address for mms Id = " + messageId);
        while (cursor.moveToNext()) {
            senderAddress = cursor.getString(cursor.getColumnIndex("address"));
            Log.d(TAG, "Found sender address = " + senderAddress + " for mms Id = " + messageId);
        }
        cursor.close();
        if (senderAddress == null) {
            return null;
        }
        cursor = this.context.getContentResolver().query(uri, null, new String("msg_id=" + messageId + " AND type=" + 151), null, null);
        Log.d(TAG, "Found " + cursor.getCount() + " recipient addresses for mms Id = " + messageId);
        while (cursor.moveToNext()) {
            String address = cursor.getString(cursor.getColumnIndex("address"));
            recipientAddresses.add(address);
            Log.d(TAG, "Found recipient address = " + address + " for mms Id = " + messageId);
        }
        cursor.close();
        String myAddress = ((TelephonyManager) this.context.getSystemService("phone")).getLine1Number();
        Log.d(TAG, "Removing my address from recipients" + myAddress);
        removeAddress(myAddress, recipientAddresses);
        cursor = this.context.getContentResolver().query(Uri.parse("content://mms/part"), null, new String("mid=" + messageId), null, null);
        Log.d(TAG, "Found " + cursor.getCount() + " parts for mms Id = " + messageId);
        while (cursor.moveToNext()) {
            String contentType = cursor.getString(cursor.getColumnIndex("ct"));
            message = getMessageForContentType(contentType);
            if (message != null) {
                break;
            } else if ("text/plain".equals(contentType)) {
                message = cursor.getString(cursor.getColumnIndex("text"));
                break;
            } else {
                Log.d(TAG, "Skipping part with contentType = " + contentType);
            }
        }
        cursor.close();
        if (message == null) {
            return null;
        }
        Log.d(TAG, "Found MMS addess = " + senderAddress + "   |   message = " + message + "   |   id = " + messageId);
        return new MmsMessage(senderAddress, recipientAddresses, message);
    }

    void removeAddress(String addressToRemove, List<String> addresses) {
        if (addressToRemove != null) {
            Iterator<String> i = addresses.iterator();
            while (i.hasNext()) {
                String address = (String) i.next();
                if (address.contains(addressToRemove) || addressToRemove.contains(address)) {
                    i.remove();
                }
            }
        }
    }

    String getMessageForContentType(String contentType) {
        for (String contentTypeImage : CONTENT_TYPE_IMAGES) {
            if (contentTypeImage.equals(contentType)) {
                return this.context.getResources().getString(R.string.entry_of_message_photo);
            }
        }
        for (String contentTypeImage2 : CONTENT_TYPE_VIDEOS) {
            if (contentTypeImage2.equals(contentType)) {
                return this.context.getResources().getString(R.string.entry_of_message_multimedia);
            }
        }
        for (String contentTypeImage22 : CONTENT_TYPE_AUDIO) {
            if (contentTypeImage22.equals(contentType)) {
                return this.context.getResources().getString(R.string.entry_of_message_audio);
            }
        }
        for (String contentTypeImage222 : CONTENT_TYPE_CONTACTS) {
            if (contentTypeImage222.equals(contentType)) {
                return this.context.getResources().getString(R.string.entry_of_message_contact);
            }
        }
        for (String contentTypeImage2222 : CONTENT_TYPE_CALENDARS) {
            if (contentTypeImage2222.equals(contentType)) {
                return this.context.getResources().getString(R.string.entry_of_message_calendar_appointment);
            }
        }
        if (CONTENT_TYPE_HTML.equals(contentType)) {
            return this.context.getResources().getString(R.string.entry_of_message_notext);
        }
        return null;
    }

    public interface MmsListener {
        void onMmsReceived(MmsMessage mmsMessage);
    }

    class MmsContentObserver extends ContentObserver {
        public MmsContentObserver(Handler handler) {
            super(handler);
        }

        public void onChange(boolean selfChange, Uri uri) {
            super.onChange(selfChange, uri);
            MmsMonitor.this.onConversationDatabaseChanged();
        }
    }

    class MmsDownloadedReceiver extends BroadcastReceiver {
        MmsDownloadedReceiver() {
        }

        public void onReceive(Context context, Intent intent) {
            if (intent.getAction().equals(MmsMonitor.ACTION_MMS_DOWNLOADED)) {
                MmsMonitor.this.onConversationDatabaseChanged();
            }
        }
    }

    public class MmsMessage {
        String message;
        List<String> recipientAddresses;
        String senderAddress;

        public MmsMessage(String senderAddress, List<String> recipientAddresses, String message) {
            this.senderAddress = senderAddress;
            this.recipientAddresses = recipientAddresses;
            this.message = message;
        }

        public String getSenderAddress() {
            return this.senderAddress;
        }

        public List<String> getRecipientAddresses() {
            return this.recipientAddresses;
        }

        public String getMessage() {
            return this.message;
        }
    }

    class PendingMms {
        long messageId;
        long timestamp;

        PendingMms(long messageId, long timestamp) {
            this.messageId = messageId;
            this.timestamp = timestamp;
        }
    }
}
