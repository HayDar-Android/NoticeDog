/*
 * Copyright (c) NoticeDog 2017.
 * GNU LESSER GENERAL PUBLIC LICENSE
 *     Version 3, 29 June 2007
 *
 * Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 * Everyone is permitted to copy and distribute verbatim copies
 * of this license document, but changing it is not allowed.
 *
 *
 * This version of the GNU Lesser General Public License incorporates
 * the terms and conditions of version 3 of the GNU General Public
 * License, supplemented by the additional permissions listed below.
 *
 * 0. Additional Definitions.
 *
 * As used herein, "this License" refers to version 3 of the GNU Lesser
 * General Public License, and the "GNU GPL" refers to version 3 of the GNU
 * General Public License.
 *
 * "The Library" refers to a covered work governed by this License,
 * other than an Application or a Combined Work as defined below.
 *
 * An "Application" is any work that makes use of an interface provided
 * by the Library, but which is not otherwise based on the Library.
 * Defining a subclass of a class defined by the Library is deemed a mode
 * of using an interface provided by the Library.
 *
 * A "Combined Work" is a work produced by combining or linking an
 * Application with the Library.  The particular version of the Library
 * with which the Combined Work was made is also called the "Linked
 * Version".
 *
 * The "Minimal Corresponding Source" for a Combined Work means the
 * Corresponding Source for the Combined Work, excluding any source code
 * for portions of the Combined Work that, considered in isolation, are
 * based on the Application, and not on the Linked Version.
 *
 * The "Corresponding Application Code" for a Combined Work means the
 * object code and/or source code for the Application, including any data
 * and utility programs needed for reproducing the Combined Work from the
 * Application, but excluding the System Libraries of the Combined Work.
 *
 * 1. Exception to Section 3 of the GNU GPL.
 *
 * You may convey a covered work under sections 3 and 4 of this License
 * without being bound by section 3 of the GNU GPL.
 *
 * 2. Conveying Modified Versions.
 *
 * If you modify a copy of the Library, and, in your modifications, a
 * facility refers to a function or data to be supplied by an Application
 * that uses the facility (other than as an argument passed when the
 * facility is invoked), then you may convey a copy of the modified
 * version:
 *
 * a) under this License, provided that you make a good faith effort to
 * ensure that, in the event an Application does not supply the
 * function or data, the facility still operates, and performs
 * whatever part of its purpose remains meaningful, or
 *
 * b) under the GNU GPL, with none of the additional permissions of
 * this License applicable to that copy.
 *
 * 3. Object Code Incorporating Material from Library Header Files.
 *
 * The object code form of an Application may incorporate material from
 * a header file that is part of the Library.  You may convey such object
 * code under terms of your choice, provided that, if the incorporated
 * material is not limited to numerical parameters, data structure
 * layouts and accessors, or small macros, inline functions and templates
 * (ten or fewer lines in length), you do both of the following:
 *
 * a) Give prominent notice with each copy of the object code that the
 * Library is used in it and that the Library and its use are
 * covered by this License.
 *
 * b) Accompany the object code with a copy of the GNU GPL and this license
 * document.
 *
 * 4. Combined Works.
 *
 * You may convey a Combined Work under terms of your choice that,
 * taken together, effectively do not restrict modification of the
 * portions of the Library contained in the Combined Work and reverse
 * engineering for debugging such modifications, if you also do each of
 * the following:
 *
 * a) Give prominent notice with each copy of the Combined Work that
 * the Library is used in it and that the Library and its use are
 * covered by this License.
 *
 * b) Accompany the Combined Work with a copy of the GNU GPL and this license
 * document.
 *
 * c) For a Combined Work that displays copyright notices during
 * execution, include the copyright notice for the Library among
 * these notices, as well as a reference directing the user to the
 * copies of the GNU GPL and this license document.
 *
 * d) Do one of the following:
 *
 * 0) Convey the Minimal Corresponding Source under the terms of this
 * License, and the Corresponding Application Code in a form
 * suitable for, and under terms that permit, the user to
 * recombine or relink the Application with a modified version of
 * the Linked Version to produce a modified Combined Work, in the
 * manner specified by section 6 of the GNU GPL for conveying
 * Corresponding Source.
 *
 * 1) Use a suitable shared library mechanism for linking with the
 * Library.  A suitable mechanism is one that (a) uses at run time
 * a copy of the Library already present on the user's computer
 * system, and (b) will operate properly with a modified version
 * of the Library that is interface-compatible with the Linked
 * Version.
 *
 * e) Provide Installation Information, but only if you would otherwise
 * be required to provide such information under section 6 of the
 * GNU GPL, and only to the extent that such information is
 * necessary to install and execute a modified version of the
 * Combined Work produced by recombining or relinking the
 * Application with a modified version of the Linked Version. (If
 * you use option 4d0, the Installation Information must accompany
 * the Minimal Corresponding Source and Corresponding Application
 * Code. If you use option 4d1, you must provide the Installation
 * Information in the manner specified by section 6 of the GNU GPL
 * for conveying Corresponding Source.)
 *
 * 5. Combined Libraries.
 *
 * You may place library facilities that are a work based on the
 * Library side by side in a single library together with other library
 * facilities that are not Applications and are not covered by this
 * License, and convey such a combined library under terms of your
 * choice, if you do both of the following:
 *
 * a) Accompany the combined library with a copy of the same work based
 * on the Library, uncombined with any other library facilities,
 * conveyed under the terms of this License.
 *
 * b) Give prominent notice with the combined library that part of it
 * is a work based on the Library, and explaining where to find the
 * accompanying uncombined form of the same work.
 *
 * 6. Revised Versions of the GNU Lesser General Public License.
 *
 * The Free Software Foundation may publish revised and/or new versions
 * of the GNU Lesser General Public License from time to time. Such new
 * versions will be similar in spirit to the present version, but may
 * differ in detail to address new problems or concerns.
 *
 * Each version is given a distinguishing version number. If the
 * Library as you received it specifies that a certain numbered version
 * of the GNU Lesser General Public License "or any later version"
 * applies to it, you have the option of following the terms and
 * conditions either of that published version or of any later version
 * published by the Free Software Foundation. If the Library as you
 * received it does not specify a version number of the GNU Lesser
 * General Public License, you may choose any version of the GNU Lesser
 * General Public License ever published by the Free Software Foundation.
 *
 * If the Library as you received it specifies that a proxy can decide
 * whether future versions of the GNU Lesser General Public License shall
 * apply, that proxy's public statement of acceptance of any version is
 * permanent authorization for you to choose that version for the
 * Library.
 */

package io.bunnyblue.noticedog.app.shade.ui;

import android.animation.Animator;
import android.animation.Animator.AnimatorListener;
import android.animation.ObjectAnimator;
import android.animation.TimeAnimator;
import android.animation.TimeAnimator.TimeListener;
import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.os.Handler;
import android.os.Looper;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;
import android.widget.RelativeLayout;

import com.android.volley.DefaultRetryPolicy;

import java.io.FileDescriptor;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.Iterator;

import io.bunnyblue.noticedog.app.R;

public class PanelView extends RelativeLayout {
    public static final boolean BRAKES = false;
    public static final boolean DEBUG = false;
    public static final boolean DEBUG_NAN = true;
    public static final String PEEK_COMPLETE = "PanelView.PEEK_COMPLETE";
    public static final String TAG = PanelView.class.getSimpleName();
    static float FRACTION_FULLY_EXPANDED = 0.97f;
    protected float mFinalTouchY;
    protected float mInitialTouchY;
    Handler handler;
    TimeListener mAnimationCallback;
    PanelBar mBar;
    Runnable mStopAnimator;
    private int[] mAbsPos = new int[2];
    private float mAccel;
    private float mBrakingSpeedPx = 150.0f;
    private boolean mClosing;
    private float mCollapseAccelPx;
    private float mCollapseBrakingDistancePx = 200.0f;
    private float mCollapseMinDisplayFraction;
    private float mExpandAccelPx;
    private float mExpandBrakingDistancePx = 150.0f;
    private float mExpandMinDisplayFraction;
    private float mExpandedFraction = 0.0f;
    private float mExpandedHeight = 0.0f;
    Runnable closePanelsRunnable = new Runnable() {
        public void run() {
            PanelView.this.mExpandedHeight = 0.0f;
            PanelView.this.mBar.closePanels();
        }
    };
    private float mFlingCollapseMinVelocityPx;
    private float mFlingExpandMinVelocityPx;
    private float mFlingGestureMaxOutputVelocityPx;
    private float mFlingGestureMaxXVelocityPx;
    private float mFlingGestureMinDistPx;
    private int mFullHeight = 0;
    private View mHandleView;
    private boolean mJustPeeked;
    private ObjectAnimator mPeekAnimator;
    private float mPeekHeight;
    private boolean mRubberbanding;
    private boolean mRubberbandingEnabled = true;
    private float mSelfCollapseVelocityPx;
    private float mSelfExpandVelocityPx;
    private TimeAnimator mTimeAnimator;
    private float mTouchOffset;
    private boolean mTracking;
    private float mVel;
    private FlingTracker mVelocityTracker;
    private String mViewName;

    public PanelView(Context context, AttributeSet attrs) {
        super(context, attrs);
        if (!isInEditMode()) {
            init();
        }
    }

    public final void LOG(String fmt, Object... args) {
    }

    void init() {
        this.handler = new Handler(Looper.getMainLooper());
        this.mAnimationCallback = new TimeListener() {
            public void onTimeUpdate(TimeAnimator animation, long totalTime, long deltaTime) {
                PanelView.this.animationTick(deltaTime);
            }
        };
        this.mStopAnimator = new Runnable() {
            public void run() {
                if (PanelView.this.mTimeAnimator != null && PanelView.this.mTimeAnimator.isStarted()) {
                    PanelView.this.LOG("Stop Animator : stopping", new Object[0]);
                    PanelView.this.mTimeAnimator.end();
                    PanelView.this.mRubberbanding = false;
                    PanelView.this.mClosing = false;
                }
            }
        };
        this.mTimeAnimator = new TimeAnimator();
        this.mTimeAnimator.setTimeListener(this.mAnimationCallback);
    }

    public void setRubberbandingEnabled(boolean enable) {
        this.mRubberbandingEnabled = enable;
    }

    private void runPeekAnimation() {
        if (!this.mTimeAnimator.isStarted()) {
            if (this.mPeekAnimator == null) {
                this.mPeekAnimator = ObjectAnimator.ofFloat(this, "expandedHeight", new float[]{this.mPeekHeight}).setDuration(250);
                this.mPeekAnimator.addListener(new AnimatorListener() {
                    public void onAnimationStart(Animator animation) {
                    }

                    public void onAnimationEnd(Animator animation) {
                        PanelView.this.getContext().sendBroadcast(new Intent(PanelView.PEEK_COMPLETE));
                    }

                    public void onAnimationCancel(Animator animation) {
                    }

                    public void onAnimationRepeat(Animator animation) {
                    }
                });
            }
            this.mPeekAnimator.start();
        }
    }

    private void animationTick(long dtms) {
        boolean z = true;
        if (!this.mTimeAnimator.isStarted()) {
            this.mTimeAnimator = new TimeAnimator();
            this.mTimeAnimator.setTimeListener(this.mAnimationCallback);
            if (this.mPeekAnimator != null) {
                this.mPeekAnimator.cancel();
            }
            this.mTimeAnimator.start();
            boolean z2 = this.mRubberbandingEnabled && this.mExpandedHeight > getFullHeight() && this.mVel >= (-this.mFlingGestureMinDistPx);
            this.mRubberbanding = z2;
            if (this.mRubberbanding) {
                this.mClosing = true;
            } else if (this.mVel == 0.0f) {
                if (this.mFinalTouchY / getFullHeight() >= 0.5f) {
                    z = false;
                }
                this.mClosing = z;
            } else {
                if (this.mExpandedHeight <= 0.0f || this.mVel >= 0.0f) {
                    z = false;
                }
                this.mClosing = z;
            }
        } else if (dtms > 0) {
            float dt = ((float) dtms) * 0.001f;
            float fh = getFullHeight();
            this.mAccel = this.mClosing ? -this.mCollapseAccelPx : this.mExpandAccelPx;
            this.mVel += this.mAccel * dt;
            if (false) {
                if (this.mClosing && this.mVel > (-this.mBrakingSpeedPx)) {
                    this.mVel = -this.mBrakingSpeedPx;
                } else if (!this.mClosing && this.mVel < this.mBrakingSpeedPx) {
                    this.mVel = this.mBrakingSpeedPx;
                }
            } else if (this.mClosing && this.mVel > (-this.mFlingCollapseMinVelocityPx)) {
                this.mVel = -this.mFlingCollapseMinVelocityPx;
            } else if (!this.mClosing && this.mVel > this.mFlingGestureMaxOutputVelocityPx) {
                this.mVel = this.mFlingGestureMaxOutputVelocityPx;
            }
            float h = this.mExpandedHeight + (this.mVel * dt);
            if (this.mRubberbanding && h < fh) {
                h = fh;
            }
            setExpandedHeightInternal(h);
            this.mBar.panelExpansionChanged(this, this.mExpandedFraction);
            if (this.mVel == 0.0f || ((this.mClosing && getTargetExpandedHeight() == 0) || ((this.mRubberbanding || !this.mClosing) && this.mExpandedHeight == fh))) {
                this.handler.post(this.mStopAnimator);
                if (this.mClosing && getTargetExpandedHeight() == 0) {
                    this.handler.post(this.closePanelsRunnable);
                }
            }
        } else {
            Log.v(TAG, "animationTick called with dtms=" + dtms + "; nothing to do (h=" + this.mExpandedHeight + " v=" + this.mVel + ")");
        }
    }

    private void loadDimens() {
        Resources res = getContext().getResources();
        this.mSelfExpandVelocityPx = res.getDimension(R.dimen.self_expand_velocity);
        this.mSelfCollapseVelocityPx = res.getDimension(R.dimen.self_collapse_velocity);
        this.mFlingExpandMinVelocityPx = res.getDimension(R.dimen.fling_expand_min_velocity);
        this.mFlingCollapseMinVelocityPx = res.getDimension(R.dimen.fling_collapse_min_velocity);
        this.mFlingGestureMinDistPx = res.getDimension(R.dimen.fling_gesture_min_dist);
        this.mCollapseMinDisplayFraction = res.getFraction(R.fraction.collapse_min_display_fraction, 1, 1);
        this.mExpandMinDisplayFraction = res.getFraction(R.fraction.expand_min_display_fraction, 1, 1);
        this.mExpandAccelPx = res.getDimension(R.dimen.expand_accel);
        this.mCollapseAccelPx = res.getDimension(R.dimen.collapse_accel);
        this.mFlingGestureMaxXVelocityPx = res.getDimension(R.dimen.fling_gesture_max_x_velocity);
        this.mFlingGestureMaxOutputVelocityPx = res.getDimension(R.dimen.fling_gesture_max_output_velocity);
        this.mPeekHeight = (((float) getPaddingBottom()) + res.getDimension(R.dimen.peek_height)) - ((float) (this.mHandleView == null ? 0 : this.mHandleView.getPaddingTop()));
    }

    private void trackMovement(MotionEvent event) {
        float deltaX = event.getRawX() - event.getX();
        float deltaY = event.getRawY() - event.getY();
        event.offsetLocation(deltaX, deltaY);
        if (this.mVelocityTracker != null) {
            this.mVelocityTracker.addMovement(event);
        }
        event.offsetLocation(-deltaX, -deltaY);
    }

    public boolean onTouchEvent(MotionEvent event) {
        return this.mHandleView.dispatchTouchEvent(event);
    }

    public void setHandleView(View handleView) {
        this.mHandleView = handleView;
        loadDimens();
        if (this.mHandleView != null) {
            this.mHandleView.setOnTouchListener(new OnTouchListener() {
                public boolean onTouch(View v, MotionEvent event) {
                    float y = event.getY();
                    float rawY = event.getRawY();
                    PanelView.this.getLocationOnScreen(PanelView.this.mAbsPos);
                    switch (event.getAction()) {
                        case 0:
                            PanelView.this.mTracking = true;
                            PanelView.this.mHandleView.setPressed(true);
                            PanelView.this.postInvalidate();
                            PanelView.this.mInitialTouchY = y;
                            PanelView.this.mVelocityTracker = FlingTracker.obtain();
                            PanelView.this.trackMovement(event);
                            PanelView.this.mTimeAnimator.cancel();
                            PanelView.this.mBar.onTrackingStarted(PanelView.this);
                            PanelView.this.mTouchOffset = (rawY - ((float) PanelView.this.mAbsPos[1])) - PanelView.this.getExpandedHeight();
                            if (PanelView.this.mExpandedHeight == 0.0f) {
                                PanelView.this.mJustPeeked = true;
                                PanelView.this.runPeekAnimation();
                                break;
                            }
                            break;
                        case 1:
                        case 3:
                            PanelView.this.mFinalTouchY = y;
                            PanelView.this.mTracking = false;
                            PanelView.this.mHandleView.setPressed(false);
                            PanelView.this.postInvalidate();
                            PanelView.this.mBar.onTrackingStopped(PanelView.this);
                            PanelView.this.trackMovement(event);
                            float vel = 0.0f;
                            boolean negative = false;
                            if (PanelView.this.mVelocityTracker != null) {
                                PanelView.this.mVelocityTracker.computeCurrentVelocity(1000);
                                float yVel = PanelView.this.mVelocityTracker.getYVelocity();
                                negative = yVel < 0.0f;
                                float xVel = PanelView.this.mVelocityTracker.getXVelocity();
                                if (xVel < 0.0f) {
                                    xVel = -xVel;
                                }
                                if (xVel > PanelView.this.mFlingGestureMaxXVelocityPx) {
                                    xVel = PanelView.this.mFlingGestureMaxXVelocityPx;
                                }
                                vel = (float) Math.hypot((double) yVel, (double) xVel);
                                if (vel > PanelView.this.mFlingGestureMaxOutputVelocityPx) {
                                    vel = PanelView.this.mFlingGestureMaxOutputVelocityPx;
                                }
                                PanelView.this.mVelocityTracker.recycle();
                                PanelView.this.mVelocityTracker = null;
                            }
                            if (Math.abs(PanelView.this.mFinalTouchY - PanelView.this.mInitialTouchY) < PanelView.this.mFlingGestureMinDistPx || vel < PanelView.this.mFlingExpandMinVelocityPx) {
                                vel = 0.0f;
                            }
                            if (negative) {
                                vel = -vel;
                            }
                            PanelView.this.fling(vel, true);
                            break;
                        case 2:
                            float h = (rawY - ((float) PanelView.this.mAbsPos[1])) - PanelView.this.mTouchOffset;
                            if (h > PanelView.this.mPeekHeight) {
                                if (PanelView.this.mPeekAnimator != null && PanelView.this.mPeekAnimator.isStarted()) {
                                    PanelView.this.mPeekAnimator.cancel();
                                }
                                PanelView.this.mJustPeeked = false;
                            }
                            if (!PanelView.this.mJustPeeked) {
                                PanelView.this.setExpandedHeightInternal(h);
                                PanelView.this.mBar.panelExpansionChanged(PanelView.this, PanelView.this.mExpandedFraction);
                            }
                            PanelView.this.trackMovement(event);
                            break;
                    }
                    return true;
                }
            });
        }
    }

    protected void onFinishInflate() {
        super.onFinishInflate();
    }

    public void fling(float vel, boolean always) {
        this.mVel = vel;
        if (always || this.mVel != 0.0f) {
            animationTick(0);
        }
    }

    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
        this.mViewName = "PanelView";
    }

    public String getName() {
        return this.mViewName;
    }

    public View getHandle() {
        return this.mHandleView;
    }

    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int newHeight = getMeasuredHeight();
        if (newHeight != this.mFullHeight) {
            this.mFullHeight = newHeight;
            if (!(this.mTracking || this.mRubberbanding || this.mTimeAnimator.isStarted() || this.mExpandedHeight <= 0.0f || this.mExpandedHeight == ((float) this.mFullHeight))) {
                this.mExpandedHeight = (float) this.mFullHeight;
            }
        }
        setMeasuredDimension(widthMeasureSpec, MeasureSpec.makeMeasureSpec(getTargetExpandedHeight(), Integer.MIN_VALUE));
    }

    private int getTargetExpandedHeight() {
        int targetHeight = (int) this.mExpandedHeight;
        if (this.mTouchOffset < 0.0f) {
            targetHeight = (int) (this.mExpandedHeight + this.mTouchOffset);
        }
        if (this.mExpandedHeight == ((float) this.mFullHeight)) {
            targetHeight = this.mFullHeight;
        }
        if (targetHeight < 0) {
            return 0;
        }
        return targetHeight;
    }

    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        super.onLayout(changed, left, top, right, bottom);
    }

    public void setExpandedHeightInternal(float h) {
        float f = 0.0f;
        if (Float.isNaN(h)) {
            Log.v(TAG, "setExpandedHeightInternal: warning: h=NaN, using 0 instead", new Throwable());
            h = 0.0f;
        }
        float fh = getFullHeight();
        if (fh == 0.0f) {
        }
        if (h < 0.0f) {
            h = 0.0f;
        }
        if (!(this.mRubberbandingEnabled && (this.mTracking || this.mRubberbanding)) && h > fh) {
            h = fh;
        }
        this.mExpandedHeight = h;
        ((PanelHolder) getParent()).setExpandedHeight((float) getTargetExpandedHeight());
        requestLayout();
        if (fh != 0.0f) {
            f = h / fh;
        }
        this.mExpandedFraction = Math.min(DefaultRetryPolicy.DEFAULT_BACKOFF_MULT, f);
    }

    private float getFullHeight() {
        if (this.mFullHeight <= 0) {
            measure(MeasureSpec.makeMeasureSpec(-2, 1073741824), MeasureSpec.makeMeasureSpec(-2, 1073741824));
        }
        return (float) this.mFullHeight;
    }

    public float getExpandedHeight() {
        return this.mExpandedHeight;
    }

    public void setExpandedHeight(float height) {
        this.mRubberbanding = false;
        if (this.mTimeAnimator.isStarted()) {
            this.handler.post(this.mStopAnimator);
        }
        setExpandedHeightInternal(height);
        this.mBar.panelExpansionChanged(this, this.mExpandedFraction);
    }

    public float getExpandedFraction() {
        return this.mExpandedFraction;
    }

    public void setExpandedFraction(float frac) {
        if (Float.isNaN(frac)) {
            Log.v(TAG, "setExpandedFraction: frac=NaN, using 0 instead", new Throwable());
            frac = 0.0f;
        }
        setExpandedHeight(getFullHeight() * frac);
    }

    public boolean isFullyExpanded() {
        return this.mExpandedHeight >= getFullHeight();
    }

    public boolean isNearlyFullyExpanded() {
        return this.mExpandedFraction >= FRACTION_FULLY_EXPANDED;
    }

    public boolean isFullyCollapsed() {
        return this.mExpandedHeight <= 0.0f;
    }

    public boolean isCollapsing() {
        return this.mClosing;
    }

    public void setBar(PanelBar panelBar) {
        this.mBar = panelBar;
    }

    public void collapse() {
        if (!isFullyCollapsed()) {
            this.mTimeAnimator.cancel();
            this.mClosing = true;
            this.mRubberbanding = false;
            fling(-this.mSelfCollapseVelocityPx, true);
        }
    }

    public void expand() {
        if (isFullyCollapsed()) {
            this.mBar.startOpeningPanel(this);
            fling(this.mSelfExpandVelocityPx, true);
        }
    }

    public void cancelClosePanelCalls() {
        this.handler.removeCallbacks(this.closePanelsRunnable);
        this.handler.removeCallbacks(this.mStopAnimator);
    }

    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        String str;
        String str2 = "[PanelView(%s): expandedHeight=%f fullHeight=%f closing=%s tracking=%s rubberbanding=%s justPeeked=%s peekAnim=%s%s timeAnim=%s%s]";
        Object[] objArr = new Object[11];
        objArr[0] = getClass().getSimpleName();
        objArr[1] = Float.valueOf(getExpandedHeight());
        objArr[2] = Float.valueOf(getFullHeight());
        if (this.mClosing) {
            str = "T";
        } else {
            str = "f";
        }
        objArr[3] = str;
        if (this.mTracking) {
            str = "T";
        } else {
            str = "f";
        }
        objArr[4] = str;
        if (this.mRubberbanding) {
            str = "T";
        } else {
            str = "f";
        }
        objArr[5] = str;
        if (this.mJustPeeked) {
            str = "T";
        } else {
            str = "f";
        }
        objArr[6] = str;
        objArr[7] = this.mPeekAnimator;
        if (this.mPeekAnimator == null || !this.mPeekAnimator.isStarted()) {
            str = "";
        } else {
            str = " (started)";
        }
        objArr[8] = str;
        objArr[9] = this.mTimeAnimator;
        if (this.mTimeAnimator == null || !this.mTimeAnimator.isStarted()) {
            str = "";
        } else {
            str = " (started)";
        }
        objArr[10] = str;
        pw.println(String.format(str2, objArr));
    }

    private static class FlingTracker {
        static final boolean DEBUG = false;
        static FlingTracker sTracker;
        final float DECAY = 0.75f;
        final int MAX_EVENTS = 8;
        ArrayDeque<MotionEventCopy> mEventBuf = new ArrayDeque(8);
        float mVX;
        float mVY = 0.0f;

        static FlingTracker obtain() {
            if (sTracker == null) {
                sTracker = new FlingTracker();
            }
            return sTracker;
        }

        public void addMovement(MotionEvent event) {
            if (this.mEventBuf.size() == 8) {
                this.mEventBuf.remove();
            }
            this.mEventBuf.add(new MotionEventCopy(event.getX(), event.getY(), event.getEventTime()));
        }

        public void computeCurrentVelocity(long timebase) {
            this.mVY = 0.0f;
            this.mVX = 0.0f;
            MotionEventCopy last = null;
            int i = 0;
            float totalweight = 0.0f;
            float weight = 10.0f;
            Iterator<MotionEventCopy> iter = this.mEventBuf.descendingIterator();
            while (iter.hasNext()) {
                MotionEventCopy event = (MotionEventCopy) iter.next();
                if (last != null) {
                    float dt = ((float) (event.t - last.t)) / ((float) timebase);
                    float dy = event.y - last.y;
                    this.mVX += (weight * (event.x - last.x)) / dt;
                    this.mVY += (weight * dy) / dt;
                    totalweight += weight;
                    weight *= 0.75f;
                }
                last = event;
                i++;
            }
            if (totalweight > 0.0f) {
                this.mVX /= totalweight;
                this.mVY /= totalweight;
                return;
            }
            Log.v("FlingTracker", "computeCurrentVelocity warning: totalweight=0", new Throwable());
            this.mVY = 0.0f;
            this.mVX = 0.0f;
        }

        public float getXVelocity() {
            if (Float.isNaN(this.mVX)) {
                Log.v("FlingTracker", "warning: vx=NaN");
                this.mVX = 0.0f;
            }
            return this.mVX;
        }

        public float getYVelocity() {
            if (Float.isNaN(this.mVY)) {
                Log.v("FlingTracker", "warning: vx=NaN");
                this.mVY = 0.0f;
            }
            return this.mVY;
        }

        public void recycle() {
            this.mEventBuf.clear();
        }

        private static class MotionEventCopy {
            public long t;
            public float x;
            public float y;

            public MotionEventCopy(float x2, float y2, long eventTime) {
                this.x = x2;
                this.y = y2;
                this.t = eventTime;
            }
        }
    }
}
